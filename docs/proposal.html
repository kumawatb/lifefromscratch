<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bhaskar Kumawat">

<title>proposal – Life from Scratch Development Log</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-352869b946db57d32e46d840fcc91316.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./proposal.html">CMPLXSYS 530</a></li><li class="breadcrumb-item"><a href="./proposal.html">Project Proposal</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Life from Scratch Development Log</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">CMPLXSYS 530</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./proposal.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Project Proposal</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./finalpaper.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Final Paper</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Utilities</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chemgen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chemistry Generator</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="proposal.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./proposal.html">CMPLXSYS 530</a></li><li class="breadcrumb-item"><a href="./proposal.html">Project Proposal</a></li></ol></nav>
<div class="quarto-title">
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Bhaskar Kumawat </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="project-proposal" class="level1 unnumbered">
<h1 class="unnumbered">Project Proposal</h1>
<section id="model-proposal-for-life-from-scratch" class="level2">
<h2 class="anchored" data-anchor-id="model-proposal-for-life-from-scratch">Model Proposal for Life from Scratch</h2>
<p><strong>Bhaskar Kumawat</strong></p>
<ul>
<li>Course ID: CMPLXSYS 530</li>
<li>Course Title: Computer Modeling of Complex systems</li>
<li>Term: Winter, 2025</li>
</ul>
</section>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<section id="goal" class="level3">
<h3 class="anchored" data-anchor-id="goal">Goal</h3>
<p>I wish to model the origin of self-replication in a 2D world consisting of atoms that move and bond with each other based on some physical and chemical rules. My goal for this class project would be to get any sort of self-replication in this system after millions of time-steps, but I wish to extend it to get <em>Replication Involving Replicable Imperfections</em> (RIRI). RIRI is characterised by molecules (i.e.&nbsp;groups of bonded atoms) creating robust copies while also copying any errors that may have appeared previously in the process <span class="citation" data-cites="Benner2014-cq">(<a href="#ref-Benner2014-cq" role="doc-biblioref">Benner 2014</a>)</span>.</p>
</section>
<section id="rationale" class="level3">
<h3 class="anchored" data-anchor-id="rationale">Rationale</h3>
<p>Out of all possible <em>chemistries</em> (set of bonding rules between species of atoms) that can exist, only some are likely to give rise to self-replicating molecules. Further, the environmental conditions (other atoms in the surroundings, temperature etc.) can vitally affect whether a chemistry is able to sustain self-replication. This project aims to explore the conditions that are required for self-replication to arise in a simple physical system, given arbitrary interaction rules and environments. I believe that a 2D world consisting of atoms that follow some physics-y rules (eg. diffusion and collisions) should be sufficient to observe these phenomena. Indeed, simpler, yet similar grid-based simulations have shown this “origin of self-replication” for one particular set of rules <span class="citation" data-cites="Hutton2002-gz">(<a href="#ref-Hutton2002-gz" role="doc-biblioref">Hutton 2002</a>)</span>. However, I wish to test this for a large number of randomly generated chemistries to test some general hypothesis about origin of life.</p>
</section>
<section id="main-micro-level-processes-and-macro-level-dynamics-of-interest" class="level3">
<h3 class="anchored" data-anchor-id="main-micro-level-processes-and-macro-level-dynamics-of-interest">Main Micro-level Processes and Macro-level Dynamics of Interest</h3>
<p>The simulation world that I’m building consists of a 2D plane over which a large number of circular “atom” agents reside. Each atom has a <code>species</code> and a <code>state</code> (both being integer values between 0 and 255). The main processes that these atoms undergo and the expected emergent dynamics are as follows:</p>
<p><strong><em>Micro-level processes</em></strong></p>
<ul>
<li>Atomic Diffusion: Each atom performs a random 2D motion similar to a Brownian particle in a viscous fluid.</li>
<li>Atomic Collisions: Atoms are solid bodies and collide with each other when they come in contact.</li>
<li>Bonding &amp; bond-breaking: The program allows the user to specify any chemistry in terms of creation and decomposition of bonds between atoms. Bonds are created and broken probabilistically based on collisions. If two atoms of given species and state (as specified by the <em>chemistry</em>) collide, they can form a bond with some probability. On the other hand, if two atoms of given species and state (also specified in the chemistry) are already bonded, they may break with some probability.</li>
</ul>
<p><strong><em>Macro-level/emergent dynamics</em></strong></p>
<ul>
<li>Self-replication: Self-replication is described as a process where groups of atoms (or molecules) are able to sustain continual creation of self-similar copies in the simulation world. Previous work has shown this is indeed possible in a similar system, but only for a very specific set of bonding rules <span class="citation" data-cites="Hutton2002-gz">(<a href="#ref-Hutton2002-gz" role="doc-biblioref">Hutton 2002</a>)</span>.</li>
<li>Evolution: Evolution is the process by which these molecules change as they self-replicate, but in a way that these errors are retained in future replications. Thus, RIRI (Replication involving replicable imperfections) is an important requirement for us to observe evolution in this system <span class="citation" data-cites="Benner2014-cq Fontana1998-de">(<a href="#ref-Benner2014-cq" role="doc-biblioref">Benner 2014</a>; <a href="#ref-Fontana1998-de" role="doc-biblioref">Fontana and Schuster 1998</a>)</span>.</li>
</ul>
</section>
</section>
<section id="model" class="level2">
<h2 class="anchored" data-anchor-id="model">Model</h2>
<p>The model consists of a 2D plane with circular atoms that move around and collide with each other. Collisions can lead to “reactions” where two atoms (assuming they are compatible) can bond with each other to form a molecule. Molecules can also decompose into atoms based on the reactions that are allowed. The set of reactions being used for a given simulation is called a “chemistry”. The following diagram shows an example chemistry and the resulting simulation world at a particular time.</p>
<div id="fig-proposal" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-proposal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./images/proposalschematic.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-proposal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Schematic of the simulation world and the flow of the model. Colors of the atoms denote their species and the integer label denotes their state. States can change during reactions but the species is invariant.
</figcaption>
</figure>
</div>
<section id="environment" class="level3">
<h3 class="anchored" data-anchor-id="environment">1) Environment</h3>
<p>The will have a finite, continuous 2D space with reflecting boundaries (i.e.&nbsp;walls). For now, I’m keeping the temperature constant across the world, but I envision having the temperature as a continuous function over the simulation environment. I also plan to add some sources and sinks in the world for atoms to enter and leave the system, thus allowing some sort of “selection” to emerge naturally.</p>
</section>
<section id="agents" class="level3">
<h3 class="anchored" data-anchor-id="agents">2) Agents</h3>
<p>The agents are circular “atoms” in a 2D world. All agents are the same size and have both a position in the world and a velocity (both of which are 2-dimensional float vectors). Each atom also has a “species” and a “state” property, both of which are integral values between 0 and 255. The species of an atom remains constant throughout the simulation but the state can change during reactions. Atoms diffuse through the world performing a random walk and can react with other atoms when they collide. These reactions can either form a “bond” between atoms, joining them together as they move around the world, or simply change their state without bonding. Bonded atoms (a <em>molecule</em>) can also decompose into their constituents. Interactions are entirely dependent on collisions and thus on spatial proximity between the atoms.</p>
</section>
<section id="model-scheduling" class="level3">
<h3 class="anchored" data-anchor-id="model-scheduling">3) Model Scheduling</h3>
<p>A schematic of the model schedule is shown in figure <a href="#fig-proposal" class="quarto-xref">Figure&nbsp;1</a>. The entire setup can be essentially divided into four parts.</p>
<ul>
<li><strong>Initialization</strong>: Here, the program initializes the parameters and chemistries required for the simulation. It also generates a random initial state for the system based on a random number seed and the initial number of atoms (provided as parameters).</li>
</ul>
<p>The following steps are repeated until the user ends the simulation:</p>
<ul>
<li><strong>Diffusion</strong>: Here, each atom is assigned a random velocity in any direction (with magnitude proportional the the <code>temperature</code> parameter). Then, the simulation is progressed by a single time-step (of length <span class="math inline">\(dt\)</span>) so the velocity change appears as a displacement of the atoms.</li>
<li><strong>Resolve collisions/bonds</strong>: In this step, the simulation takes note of all collisions (overlapping atoms) and bond extensions and tries to resolve them by moving the atoms by some computed distance. This step is performed 8x times because sometimes resolving collision between two atoms may create other collisions in the world.</li>
<li><strong>Reaction</strong>: Here, all atom pairs that collided with each other are checked for a “reaction” by looking their species/states up in the user specified chemistry. If two atoms can react, they are either bonded or their state is changed probabilistically based on the reaction probability (also specified by the user). Bonded atoms are also checked for decomposition.</li>
</ul>
</section>
<section id="model-parameters-and-initialization" class="level3">
<h3 class="anchored" data-anchor-id="model-parameters-and-initialization">4) Model Parameters and Initialization</h3>
<p>The main user defined parameters (apart from the chemistry) are as follows:</p>
<ul>
<li><code>size_x</code>, <code>size_y</code>: Size of the simulation world in arbitrary units.</li>
<li><code>diameter</code>: Diameter of an atom</li>
<li><code>temperature</code>: Temperature of the world, determines how random an atoms’ movement is.</li>
<li><code>init_atoms</code>: Initial number of atoms in the world.</li>
</ul>
<p>The model is initialized by first obtaining these parameters from the user through the command line. Then, the program randomly samples <code>init_atoms</code> number of locations in the simulation world to create the initial world state.</p>
</section>
<section id="assessment-and-outcome-measures" class="level3">
<h3 class="anchored" data-anchor-id="assessment-and-outcome-measures">5) Assessment and Outcome Measures</h3>
<p>For the purpose of quantifying self-replication, I will output all molecules and their numbers that are present in the system every few time-steps. These numbers can be simply plotted over time to check if there is a sudden explosive increase in the population of a particular molecule, indicating self-replication.</p>
<p>I will perform a similar analysis with a lot of randomly generated chemistries to find chemistries that allow self-replication. Then, I will narrow down on chemistries where the succesion between replicating molecules is such that it qualifies for the definition of replication with replicable imperfections: i.e., new self-replicators are similar to old self-replicators but are also stable and do not revert to an earlier state.</p>
</section>
<section id="parameter-exploration" class="level3">
<h3 class="anchored" data-anchor-id="parameter-exploration">6) Parameter Exploration</h3>
<p>The most interesting parameter to vary here would be temperature, as it allows an increase in the possiblity of chance encounters between far apart molecules and atoms. However, instead of varying the parameter between simulations, I might opt for a larger world with heterogeneous temperature at different points in the world. I hypothesis that a more “hetergeneous” world such as this would lead to self-replication faster than a homogeneous temperature simulation.</p>
</section>
</section>
<section id="questions-and-challenges" class="level2">
<h2 class="anchored" data-anchor-id="questions-and-challenges">Questions and challenges</h2>
<p><strong>Question</strong></p>
<ol type="1">
<li>Rigid vs flexible bonds: There are essentially two ways to create a bond between atoms. In the first case, the atoms are allowed to rotate around the bond and a large molecule can essentially flop around in the world and does not have a rigid 2D structure. On the other hand, a rigid bond restricts the rotation of the atoms and fixes the structure of the molecule to what it was when the bond was formed. I feel like the flexible case would be more interesting (both visually and in terms of allowing self-replication) but I’m not sure if that’s realistic (because real molecules are actually somewhat rigidly bonded to each other).</li>
</ol>
<p><strong>Challenge</strong></p>
<ol type="1">
<li>Moving to a larger simulation: According to my tests, the simulation can support around 100,000 atoms at decent speed on a somewhat powerful personal computer. I would like to scale this further and go upto maybe 1-10 million particles. I’m not sure about the techniques I could use for this, maybe performing the simulation on a GPU?</li>
</ol>
</section>
<section id="code" class="level2">
<h2 class="anchored" data-anchor-id="code">Code</h2>
<p>The code is available in the github repository <a href="https://github.com/kumawatb/lifefromscratch/tree/bevylife">here</a> (branch <code>bevylife</code>). The code is written in Rust and uses the <a href="https://bevyengine.org/">Bevy</a> game engine and the <a href="https://rapier.rs/">Rapier</a> physics library for improved performance (I tried writing these from scratch first but it’s both time consuming and not as performative as using a pre-built engine). I have implemented atomic diffusion and collisions as of now. The collisions are also reported as events that I can use to make bonds. Rigid bonding (where the bonds are NOT “floppy”) was easy to implement but is not as interesting. I’m currently trying to implement “floppy” bonds (a revolute joint). Pre-built binaries to run the current simulation on different platforms are available here:</p>
<ul>
<li>Linux: <a href="https://github.com/kumawatb/lifefromscratch/releases/download/v0.1.0-beta/lifefromscratch-linux-x86_64">64-bit</a></li>
<li>Windows: <a href="https://github.com/kumawatb/lifefromscratch/releases/download/v0.1.0-beta/lifefromscratch-win-x86_64.exe">64-bit</a></li>
<li>MacOS: <a href="https://github.com/kumawatb/lifefromscratch/releases/download/v0.1.0-beta/lifefromscratch-macos-arm">M-series Processors</a> (eg. M1-M4), <a href="https://github.com/kumawatb/lifefromscratch/releases/download/v0.1.0-beta/lifefromscratch-macos-x86_64">Intel</a></li>
</ul>
<div style="font-size: 80%;">
<p><em>If you’re not sure which one to get, just choose the first link for your operating system. If that doesn’t work, you can try the next one. Please have a look at the <a href="https://github.com/kumawatb/lifefromscratch/releases/tag/v0.1.0-beta">release page here</a> for instructions on running the program.</em></p>
</div>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Benner2014-cq" class="csl-entry" role="listitem">
Benner, Steven A. 2014. <span>“Paradoxes in the Origin of Life.”</span> <em>Origins of Life and Evolution of the Biosphere: The Journal of the International Society for the Study of the Origin of Life</em> 44 (December): 339–43.
</div>
<div id="ref-Fontana1998-de" class="csl-entry" role="listitem">
Fontana, W, and P Schuster. 1998. <span>“Continuity in Evolution: On the Nature of Transitions.”</span> <em>Science (New York, N.Y.)</em> 280 (May): 1451–55.
</div>
<div id="ref-Hutton2002-gz" class="csl-entry" role="listitem">
Hutton, Tim J. 2002. <span>“Evolvable Self-Replicating Molecules in an Artificial Chemistry.”</span> <em>Artificial Life</em> 8: 341–56.
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>